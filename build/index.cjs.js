"use strict";var t=require("intentx-state-z"),e=require("intentx-core-z");class s{constructor(){this.handlers={},this.effects={},this.middlewares=[],this.effectModes={},this.use=t=>{this.middlewares.push(t)},this.setEffectMode=(t,e)=>{this.effectModes[t]=e},this.effect=(t,e)=>{var s;((s=this.effects)[t]??(s[t]=[])).push(e)},this.on=(t,e)=>{var s;const o=(s=this.handlers)[t]??(s[t]=[]);return o.length>0?()=>{}:(o.push(e),()=>{const s=this.handlers[t];if(!s)return;const o=s.indexOf(e);0>o||s.splice(o,1),0===s.length&&delete this.handlers[t]})},this.emit=async(t,e)=>{const s=this.handlers[t]??[],o={context:e,effects:this.effects[t]??[],effectMode:this.effectModes[t]??"sequential"},i=this.middlewares.reduceRight((t,e)=>e(t),async t=>{for(const e of s)await e(t.context)});await i(o)},this.clear=()=>{this.handlers={},this.effects={},this.middlewares=[],this.effectModes={}}}}const o=()=>new s;function i(){const t=new Map,e=new Map;return s=>async o=>{await s(o);const{effects:i,effectMode:n,context:r}=o;if(!i.length)return;const a=i.map(s=>()=>(async s=>{const o=s.id;if("takeLatest"===s.strategy){t.get(o)?.abort();const e=new AbortController;return t.set(o,e),s.handler({...r,signal:e.signal})}return"debounce"===s.strategy?(clearTimeout(e.get(o)),new Promise(t=>{e.set(o,setTimeout(async()=>{await s.handler(r),t()},s.wait))})):s.handler(r)})(s));switch(n){case"parallel":await Promise.all(a.map(t=>t()));break;case"race":await Promise.race(a.map(t=>t()));break;case"allSettled":await Promise.allSettled(a.map(t=>t()));break;default:for(const t of a){const e=t();await e}}}}function n(t){return"function"==typeof structuredClone?structuredClone(t):JSON.parse(JSON.stringify(t))}function r(t){if(null===t||"object"!=typeof t)return t;Object.freeze(t);for(const e of Object.keys(t)){const s=t[e];s&&"object"==typeof s&&!Object.isFrozen(s)&&r(s)}return t}const a="production"!==("undefined"!=typeof globalThis&&void 0!==globalThis.process?globalThis.process.env?.NODE_ENV:void 0);class c{constructor(e,o=t.createScope("logic"),n){this.computedAtoms={},this.subs=new Set,this.dirty=!0,this.isComputing=!1,this.isBatching=!1,this.destroyed=!1,this.computedKeys=new Set,this.computedDisposers=new Set,this.intentDisposers=new Set,this.errorHandlers=new Set,this.leadingLocks=new Set,this.throttleMap=new Map,this.destroy=()=>{this.destroyed||(this.destroyed=!0,this.subs.clear(),this.computedDisposers.forEach(t=>t()),this.computedDisposers.clear(),this.intentDisposers.forEach(t=>t()),this.intentDisposers.clear(),this.leadingLocks.clear(),this.throttleMap.clear(),this.errorHandlers.clear(),this.computedKeys.clear(),this.dirty=!0)},this.createStateAtoms=e=>{const s={};for(const o in e)s[o]=t.atom(e[o]);return s},this.buildSnapshot=()=>{const t={};for(const e in this.stateAtoms)t[e]=this.stateAtoms[e]();for(const e in this.computedAtoms)t[e]=this.computedAtoms[e]();return a?r(t):t},this.markDirty=()=>{this.destroyed||this.isBatching||(this.dirty=!0,this.subs.forEach(t=>t()))},this.createReactiveState=()=>new Proxy({},{get:(t,e)=>{const s=this.stateAtoms[e];return s?s():void 0}}),this.getSnapshot=()=>this.destroyed?this.snapshotCache??this.buildSnapshot():(this.dirty&&(this.snapshotCache=this.buildSnapshot(),this.dirty=!1),this.snapshotCache),this.subscribe=t=>this.destroyed?()=>{}:(this.subs.add(t),()=>this.subs.delete(t)),this.batch=t=>{if(!this.destroyed){this.isBatching=!0;try{t()}finally{this.isBatching=!1,this.markDirty()}}},this.onError=t=>(this.errorHandlers.add(t),()=>this.errorHandlers.delete(t)),this.getComputedKey=t=>this.computedAtoms[t](),this.getComputed=()=>{const t=this.getSnapshot(),e={};return this.computedKeys.forEach(s=>{e[s]=t[s]}),e},this.setStateInternal=t=>{const e={};for(const t in this.stateAtoms)e[t]=this.stateAtoms[t]();t(e);for(const t in this.stateAtoms)e[t]!==this.stateAtoms[t]()&&this.stateAtoms[t].set(e[t])},this.onIntent=(t,e)=>{const s=this.bus.on(t,e);return this.intentDisposers.add(s),()=>{s(),this.intentDisposers.delete(s)}},this.once=(t,e)=>{const s=this.onIntent(t,async t=>{s(),await e(t)})},this.takeLeading=(t,e)=>{this.onIntent(t,async s=>{if(!this.leadingLocks.has(t)){this.leadingLocks.add(t);try{await e(s)}finally{this.leadingLocks.delete(t)}}})},this.throttle=(t,e,s)=>{this.onIntent(t,async o=>{const i=Date.now();i-(this.throttleMap.get(t)??0)<e||(this.throttleMap.set(t,i),await s(o))})},this.useEffect=(t,e)=>{this.bus.effect(t,e)},this.emit=async(t,e)=>{if(this.destroyed)return;const s=new AbortController;try{await this.bus.emit(t,{payload:e,scope:this.scope,signal:s.signal,state:this.getSnapshot,setState:this.setStateInternal,emit:this.emit})}catch(s){this.errorHandlers.forEach(o=>o(s,{type:t,payload:e}))}},this.attachComputed=(e,s)=>{const o=t.atom(void 0),i=this.createReactiveState();this.computedAtoms[e]=o,this.computedKeys.add(e);const n=()=>{this.destroyed||(this.isComputing=!0,o.set(s({state:i})),this.isComputing=!1)},r=t.effect(n);this.computedDisposers.add(r),n();const a=o.subscribe(this.markDirty);this.computedDisposers.add(a)},this.scope=o,this.stateAtoms=this.createStateAtoms(e);for(const t in this.stateAtoms){const e=this.stateAtoms[t].subscribe(this.markDirty);this.computedDisposers.add(e)}n?this.bus=n:(this.bus=new s,this.bus.use(i())),a&&(this.__debugId="runtime-"+Math.random().toString(36).slice(2))}get state(){return this.getSnapshot()}get computed(){const t={};return this.computedKeys.forEach(e=>{t[e]=this.computedAtoms[e]()}),t}}function h(t,e){const s=function(){let t=0,e=[];return{get records(){return e.slice()},record:function(s){e.push({...s,id:++t,state:n(s.state)})},replay:async function(t,s){const{from:o=0,to:i=1/0,scope:n}=s??{},r=e.filter(t=>!("emit"!==t.type||o>t.id||t.id>i||n&&t.scope!==n));for(const e of r){const s=t(e.intent,e.payload);s instanceof Promise&&await s}},clear:function(){e=[],t=0}}}(),o=Symbol("devtools_wrapped");function i(){const s=e||t.scope;return s?"string"==typeof s?s:s.name??"anonymous":"global"}function r(){return"function"==typeof t.getSnapshot?t.getSnapshot():"function"==typeof t.state?t.state():void 0}return{timeline:s,wrap:function(){if(t[o])return;t[o]=!0;const e=t.emit.bind(t);t.emit=async(t,o)=>{s.record({type:"emit:start",intent:t,payload:o,scope:i(),state:r(),timestamp:Date.now()});try{await Promise.resolve(e(t,o))}catch(e){throw s.record({type:"emit:error",intent:t,payload:o,scope:i(),state:r(),timestamp:Date.now()}),e}s.record({type:"emit:end",intent:t,payload:o,scope:i(),state:r(),timestamp:Date.now()})}}}}Object.defineProperty(exports,"createScope",{enumerable:!0,get:function(){return t.createScope}}),exports.LogicRuntime=c,exports.attachDevtools=h,exports.createApp=function(t){const s=e.createScope(t.name??"app"),i=o(),n={};for(const e of Object.keys(t.logics)){n[e]=t.logics[e].createShareBus(s,i)}return{scope:s,bus:i,logics:n}},exports.createBackendRuntime=function(t){let s=n(t);const o=()=>s,i=t=>{s={...s,...t}},r=e.createScope("backend"),c=new Set,d=new Set,l=new Set,u=new Map,f=e.createIntentBus((t,e)=>({scope:e,payload:t,signal:(new AbortController).signal,get state(){return o()},setState(){throw Error("[BackendRuntime] setState not allowed")},emit:m})),p=[];async function m(t,e){c.forEach(s=>s(t,e));const s=new AbortController;try{await f.emit(t,e,r);const n=u.get(t);if(n)for(const t of n)await t({state:o,set:i,emit:m,signal:s.signal},e)}catch(e){throw l.forEach(s=>s(e,t)),e}finally{d.forEach(s=>s(t,e))}}const y={state:o,reset:()=>{s=n(t)},emit:m,registerIntents:function(t){for(const e in t){const s=t[e],n=f.on(e,async t=>{const e={state:o,set:i,emit:m,signal:t.signal};await s(e,t.payload)},r);"function"==typeof n&&p.push(n)}},effect:function(t,e){return u.has(t)||u.set(t,new Set),u.get(t).add(e),()=>{u.get(t).delete(e)}},onError:t=>(l.add(t),()=>l.delete(t)),onBefore:t=>(c.add(t),()=>c.delete(t)),onAfter:t=>(d.add(t),()=>d.delete(t)),destroy(){c.clear(),d.clear(),l.clear(),u.clear();for(const t of p)t();p.length=0}};if(a&&!y.devtools){const t=h(y,"logic");t.wrap(),y.devtools=t}return y},exports.createIntentBus=o,exports.createLogic=function(t){return{name:t.name,createShareBus(t,e){return this.create(t,e)},createIsolated(t){return this.create(t,void 0)},create(e,s){const o=new c(n(t.state),e,s);if(a&&!o.devtools){const e=h(o,t.name??"logic");e.wrap(),o.devtools=e}if(t.computed)for(const e in t.computed)o.attachComputed(e,t.computed[e]);t.intents?.({on:o.onIntent,effect:(t,e)=>o.useEffect(t,e)});const i={};if(t.actions){const e=Object.keys(t.actions);for(const s of e){i[s]=(0,t.actions[s])({emit:o.emit,getState:o.getSnapshot})}}return o.actions=i,o}}},exports.deepFreeze=r,exports.effect=function(t){const e={_kind:"effect",id:Symbol("effect"),handler:t,strategy:"default"},s=(t={})=>{const o={...e,...t};return Object.assign(o,{takeLatest:()=>s({strategy:"takeLatest"}),debounce:t=>s({strategy:"debounce",wait:t}),blocking:()=>s({blocking:!0})})};return s()},exports.safeClone=n;
