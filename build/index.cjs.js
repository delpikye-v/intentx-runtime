"use strict";var t=require("intentx-state-z"),e=require("intentx-core-z");class s{constructor(){this.handlers={},this.effects={},this.middlewares=[],this.effectModes={},this.use=t=>{this.middlewares.push(t)},this.setEffectMode=(t,e)=>{this.effectModes[t]=e},this.effect=(t,e)=>{var s;((s=this.effects)[t]??(s[t]=[])).push(e)},this.on=(t,e)=>{var s;const n=(s=this.handlers)[t]??(s[t]=[]);return n.length>0?()=>{}:(n.push(e),()=>{const s=this.handlers[t];if(!s)return;const n=s.indexOf(e);0>n||s.splice(n,1),0===s.length&&delete this.handlers[t]})},this.emit=async(t,e)=>{const s=this.handlers[t]??[],n={context:e,effects:this.effects[t]??[],effectMode:this.effectModes[t]??"sequential"},o=this.middlewares.reduceRight((t,e)=>e(t),async t=>{for(const e of s)await e(t.context)});await o(n)}}}function n(){const t=new Map,e=new Map;return s=>async n=>{await s(n);const{effects:o,effectMode:i,context:a}=n;if(!o.length)return;const r=o.map(s=>()=>(async s=>{const n=s.id;if("takeLatest"===s.strategy){t.get(n)?.abort();const e=new AbortController;return t.set(n,e),s.handler({...a,signal:e.signal})}return"debounce"===s.strategy?(clearTimeout(e.get(n)),new Promise(t=>{e.set(n,setTimeout(async()=>{await s.handler(a),t()},s.wait))})):s.handler(a)})(s));switch(i){case"parallel":await Promise.all(r.map(t=>t()));break;case"race":await Promise.race(r.map(t=>t()));break;case"allSettled":await Promise.allSettled(r.map(t=>t()));break;default:for(const t of r){const e=t();await e}}}}class o{constructor(o,i=e.createScope("logic"),a){this.computedAtoms={},this.subs=new Set,this.dirty=!0,this.isComputing=!1,this.isBatching=!1,this.computedKeys=new Set,this.errorHandlers=new Set,this.leadingLocks=new Set,this.throttleMap=new Map,this.createStateAtoms=e=>{const s={};for(const n in e)s[n]=t.atom(e[n]);return s},this.buildSnapshot=()=>{const t={};for(const e in this.stateAtoms)t[e]=this.stateAtoms[e]();for(const e in this.computedAtoms)t[e]=this.computedAtoms[e]();return t},this.markDirty=()=>{this.isBatching||(this.dirty=!0,this.subs.forEach(t=>t()))},this.createReactiveState=()=>new Proxy({},{get:(t,e)=>{const s=this.stateAtoms[e];return s?s():void 0}}),this.getSnapshot=()=>(this.dirty&&(this.snapshotCache=this.buildSnapshot(),this.dirty=!1),this.snapshotCache),this.subscribe=t=>(this.subs.add(t),()=>this.subs.delete(t)),this.batch=t=>{this.isBatching=!0;try{t()}finally{this.isBatching=!1,this.markDirty()}},this.onError=t=>(this.errorHandlers.add(t),()=>this.errorHandlers.delete(t)),this.getComputedKey=t=>this.computedAtoms[t](),this.getComputed=t=>{const e={};return this.computedKeys.forEach(s=>{e[s]=t[s]}),e},this.setStateInternal=t=>{const e={};for(const t in this.stateAtoms)e[t]=this.stateAtoms[t]();t(e);for(const t in this.stateAtoms)e[t]!==this.stateAtoms[t]()&&this.stateAtoms[t].set(e[t])},this.onIntent=(t,e)=>this.bus.on(t,e),this.once=(t,e)=>{const s=this.onIntent(t,async t=>{s(),await e(t)})},this.takeLeading=(t,e)=>{this.onIntent(t,async s=>{if(!this.leadingLocks.has(t)){this.leadingLocks.add(t);try{await e(s)}finally{this.leadingLocks.delete(t)}}})},this.throttle=(t,e,s)=>{this.onIntent(t,async n=>{const o=Date.now();o-(this.throttleMap.get(t)??0)<e||(this.throttleMap.set(t,o),await s(n))})},this.useEffect=(t,e)=>{this.bus.effect(t,e)},this.emit=async(t,e)=>{const s=new AbortController;try{await this.bus.emit(t,{payload:e,scope:this.scope,signal:s.signal,state:this.getSnapshot,setState:this.setStateInternal,emit:this.emit})}catch(s){this.errorHandlers.forEach(n=>n(s,{type:t,payload:e}))}},this.attachComputed=(e,s)=>{const n=t.atom(void 0),o=this.createReactiveState();this.computedAtoms[e]=n,this.computedKeys.add(e);const i=()=>{this.isComputing=!0,n.set(s({state:o})),this.isComputing=!1};t.effect(i),i(),n.subscribe(this.markDirty)},this.scope=i,this.stateAtoms=this.createStateAtoms(o);for(const t in this.stateAtoms)this.stateAtoms[t].subscribe(this.markDirty);this.bus=a??new s,this.bus.use(n())}get state(){return this.getSnapshot()}get computed(){const t={};return this.computedKeys.forEach(e=>{t[e]=this.computedAtoms[e]()}),t}}function i(t){return"function"==typeof structuredClone?structuredClone(t):JSON.parse(JSON.stringify(t))}const a=()=>new s;function r(t){const e=function(){let t=0,e=[];return{get records(){return e.slice()},record:function(s){e.push({...s,id:++t,state:i(s.state)})},replay:async function(t,s){const{from:n=0,to:o=1/0,scope:i}=s??{},a=e.filter(t=>!("emit"!==t.type||n>t.id||t.id>o||i&&t.scope!==i));for(const e of a){const s=t(e.intent,e.payload);s instanceof Promise&&await s}},clear:function(){e=[],t=0}}}(),s=Symbol("devtools_wrapped");function n(){const e=t.scope;return e?"string"==typeof e?e:e.name??"anonymous":"global"}function o(){return"function"==typeof t.getSnapshot?t.getSnapshot():"function"==typeof t.state?t.state():void 0}return{timeline:e,wrap:function(){if(t[s])return;t[s]=!0;const i=t.emit.bind(t);t.emit=async(t,s)=>{e.record({type:"emit:start",intent:t,payload:s,scope:n(),state:o(),timestamp:Date.now()});try{await Promise.resolve(i(t,s))}catch(i){throw e.record({type:"emit:error",intent:t,payload:s,scope:n(),state:o(),timestamp:Date.now()}),i}e.record({type:"emit:end",intent:t,payload:s,scope:n(),state:o(),timestamp:Date.now()})}}}}const c="production"!==globalThis?.process?.env?.NODE_ENV;Object.defineProperty(exports,"createScope",{enumerable:!0,get:function(){return t.createScope}}),exports.LogicRuntime=o,exports.attachDevtools=r,exports.createApp=function(t){const s=e.createScope(t.name??"app"),n=a(),o={};for(const e of Object.keys(t.logics)){o[e]=t.logics[e].createShareBus(s,n)}return{scope:s,bus:n,logics:o}},exports.createBackendRuntime=function(t){let s=i(t);const n=()=>s,o=t=>{s={...s,...t}},a=e.createScope("backend"),h=new Set,d=new Set,u=new Set,l=new Map,f=e.createIntentBus((t,e)=>({scope:e,payload:t,signal:(new AbortController).signal,get state(){return n()},setState(){throw Error("[BackendRuntime] setState not allowed")},emit:m})),p=[];async function m(t,e){h.forEach(s=>s(t,e));const s=new AbortController;try{await f.emit(t,e,a);const i=l.get(t);if(i)for(const t of i)await t({state:n,set:o,emit:m,signal:s.signal},e)}catch(e){throw u.forEach(s=>s(e,t)),e}finally{d.forEach(s=>s(t,e))}}const g={state:n,reset:()=>{s=i(t)},emit:m,registerIntents:function(t){for(const e in t){const s=t[e],i=f.on(e,async t=>{const e={state:n,set:o,emit:m,signal:t.signal};await s(e,t.payload)},a);"function"==typeof i&&p.push(i)}},effect:function(t,e){return l.has(t)||l.set(t,new Set),l.get(t).add(e),()=>{l.get(t).delete(e)}},onError:t=>(u.add(t),()=>u.delete(t)),onBefore:t=>(h.add(t),()=>h.delete(t)),onAfter:t=>(d.add(t),()=>d.delete(t)),destroy(){h.clear(),d.clear(),u.clear(),l.clear();for(const t of p)t();p.length=0}};if(c){const t=r(g);t.wrap(),g.devtools=t}return g},exports.createIntentBus=a,exports.createLogic=function(t){return{name:t.name,createShareBus(t,e){return this.create(t,e)},createIsolated(t){return this.create(t,void 0)},create(e,s){const n=new o(i(t.state),e,s);if(t.computed)for(const e in t.computed)n.attachComputed(e,t.computed[e]);t.intents?.({on:n.onIntent,effect:n.useEffect.bind(n)});const a={};if(t.actions){const e=Object.keys(t.actions);for(const s of e){a[s]=(0,t.actions[s])({emit:n.emit,getState:n.getSnapshot})}}return n.actions=a,n}}},exports.effect=function(t){const e={_kind:"effect",id:Symbol("effect"),handler:t,strategy:"default"},s=(t={})=>{const n={...e,...t};return Object.assign(n,{takeLatest:()=>s({strategy:"takeLatest"}),debounce:t=>s({strategy:"debounce",wait:t}),blocking:()=>s({blocking:!0})})};return s()},exports.safeClone=i;
