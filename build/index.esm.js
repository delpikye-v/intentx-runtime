import{atom as t,effect as e}from"intentx-state-z";export{createScope}from"intentx-state-z";import{createScope as s,createIntentBus as n}from"intentx-core-z";class o{constructor(){this.handlers={},this.effects={},this.middlewares=[],this.effectModes={},this.use=t=>{this.middlewares.push(t)},this.setEffectMode=(t,e)=>{this.effectModes[t]=e},this.effect=(t,e)=>{var s;((s=this.effects)[t]??(s[t]=[])).push(e)},this.on=(t,e)=>{var s;const n=(s=this.handlers)[t]??(s[t]=[]);return n.length>0?()=>{}:(n.push(e),()=>{const s=this.handlers[t];if(!s)return;const n=s.indexOf(e);0>n||s.splice(n,1),0===s.length&&delete this.handlers[t]})},this.emit=async(t,e)=>{const s=this.handlers[t]??[],n={context:e,effects:this.effects[t]??[],effectMode:this.effectModes[t]??"sequential"},o=this.middlewares.reduceRight((t,e)=>e(t),async t=>{for(const e of s)await e(t.context)});await o(n)}}}function i(){const t=new Map,e=new Map;return s=>async n=>{await s(n);const{effects:o,effectMode:i,context:a}=n;if(!o.length)return;const r=o.map(s=>()=>(async s=>{const n=s.id;if("takeLatest"===s.strategy){t.get(n)?.abort();const e=new AbortController;return t.set(n,e),s.handler({...a,signal:e.signal})}return"debounce"===s.strategy?(clearTimeout(e.get(n)),new Promise(t=>{e.set(n,setTimeout(async()=>{await s.handler(a),t()},s.wait))})):s.handler(a)})(s));switch(i){case"parallel":await Promise.all(r.map(t=>t()));break;case"race":await Promise.race(r.map(t=>t()));break;case"allSettled":await Promise.allSettled(r.map(t=>t()));break;default:for(const t of r){const e=t();await e}}}}class a{constructor(n,a=s("logic"),r){this.computedAtoms={},this.subs=new Set,this.dirty=!0,this.isComputing=!1,this.isBatching=!1,this.computedKeys=new Set,this.errorHandlers=new Set,this.leadingLocks=new Set,this.throttleMap=new Map,this.createStateAtoms=e=>{const s={};for(const n in e)s[n]=t(e[n]);return s},this.buildSnapshot=()=>{const t={};for(const e in this.stateAtoms)t[e]=this.stateAtoms[e]();for(const e in this.computedAtoms)t[e]=this.computedAtoms[e]();return t},this.markDirty=()=>{this.isBatching||(this.dirty=!0,this.subs.forEach(t=>t()))},this.createReactiveState=()=>new Proxy({},{get:(t,e)=>{const s=this.stateAtoms[e];return s?s():void 0}}),this.getSnapshot=()=>(this.dirty&&(this.snapshotCache=this.buildSnapshot(),this.dirty=!1),this.snapshotCache),this.subscribe=t=>(this.subs.add(t),()=>this.subs.delete(t)),this.batch=t=>{this.isBatching=!0;try{t()}finally{this.isBatching=!1,this.markDirty()}},this.onError=t=>(this.errorHandlers.add(t),()=>this.errorHandlers.delete(t)),this.getComputedKey=t=>this.computedAtoms[t](),this.getComputed=t=>{const e={};return this.computedKeys.forEach(s=>{e[s]=t[s]}),e},this.setStateInternal=t=>{const e={};for(const t in this.stateAtoms)e[t]=this.stateAtoms[t]();t(e);for(const t in this.stateAtoms)e[t]!==this.stateAtoms[t]()&&this.stateAtoms[t].set(e[t])},this.onIntent=(t,e)=>this.bus.on(t,e),this.once=(t,e)=>{const s=this.onIntent(t,async t=>{s(),await e(t)})},this.takeLeading=(t,e)=>{this.onIntent(t,async s=>{if(!this.leadingLocks.has(t)){this.leadingLocks.add(t);try{await e(s)}finally{this.leadingLocks.delete(t)}}})},this.throttle=(t,e,s)=>{this.onIntent(t,async n=>{const o=Date.now();o-(this.throttleMap.get(t)??0)<e||(this.throttleMap.set(t,o),await s(n))})},this.useEffect=(t,e)=>{this.bus.effect(t,e)},this.emit=async(t,e)=>{const s=new AbortController;try{await this.bus.emit(t,{payload:e,scope:this.scope,signal:s.signal,state:this.getSnapshot,setState:this.setStateInternal,emit:this.emit})}catch(s){this.errorHandlers.forEach(n=>n(s,{type:t,payload:e}))}},this.attachComputed=(s,n)=>{const o=t(void 0),i=this.createReactiveState();this.computedAtoms[s]=o,this.computedKeys.add(s);const a=()=>{this.isComputing=!0,o.set(n({state:i})),this.isComputing=!1};e(a),a(),o.subscribe(this.markDirty)},this.scope=a,this.stateAtoms=this.createStateAtoms(n);for(const t in this.stateAtoms)this.stateAtoms[t].subscribe(this.markDirty);this.bus=r??new o,this.bus.use(i())}get state(){return this.getSnapshot()}get computed(){const t={};return this.computedKeys.forEach(e=>{t[e]=this.computedAtoms[e]()}),t}}function r(t){const e={_kind:"effect",id:Symbol("effect"),handler:t,strategy:"default"},s=(t={})=>{const n={...e,...t};return Object.assign(n,{takeLatest:()=>s({strategy:"takeLatest"}),debounce:t=>s({strategy:"debounce",wait:t}),blocking:()=>s({blocking:!0})})};return s()}function c(t){return"function"==typeof structuredClone?structuredClone(t):JSON.parse(JSON.stringify(t))}function h(t){return{name:t.name,createShareBus(t,e){return this.create(t,e)},createIsolated(t){return this.create(t,void 0)},create(e,s){const n=new a(c(t.state),e,s);if(t.computed)for(const e in t.computed)n.attachComputed(e,t.computed[e]);t.intents?.({on:n.onIntent,effect:n.useEffect.bind(n)});const o={};if(t.actions){const e=Object.keys(t.actions);for(const s of e){o[s]=(0,t.actions[s])({emit:n.emit,getState:n.getSnapshot})}}return n.actions=o,n}}}const d=()=>new o;function l(t){const e=s(t.name??"app"),n=d(),o={};for(const s of Object.keys(t.logics)){o[s]=t.logics[s].createShareBus(e,n)}return{scope:e,bus:n,logics:o}}function f(t){const e=function(){let t=0,e=[];return{get records(){return e.slice()},record:function(s){e.push({...s,id:++t,state:c(s.state)})},replay:async function(t,s){const{from:n=0,to:o=1/0,scope:i}=s??{},a=e.filter(t=>!("emit"!==t.type||n>t.id||t.id>o||i&&t.scope!==i));for(const e of a){const s=t(e.intent,e.payload);s instanceof Promise&&await s}},clear:function(){e=[],t=0}}}(),s=Symbol("devtools_wrapped");function n(){const e=t.scope;return e?"string"==typeof e?e:e.name??"anonymous":"global"}function o(){return"function"==typeof t.getSnapshot?t.getSnapshot():"function"==typeof t.state?t.state():void 0}return{timeline:e,wrap:function(){if(t[s])return;t[s]=!0;const i=t.emit.bind(t);t.emit=async(t,s)=>{e.record({type:"emit:start",intent:t,payload:s,scope:n(),state:o(),timestamp:Date.now()});try{await Promise.resolve(i(t,s))}catch(i){throw e.record({type:"emit:error",intent:t,payload:s,scope:n(),state:o(),timestamp:Date.now()}),i}e.record({type:"emit:end",intent:t,payload:s,scope:n(),state:o(),timestamp:Date.now()})}}}}const u="production"!==globalThis?.process?.env?.NODE_ENV;function m(t){let e=c(t);const o=()=>e,i=t=>{e={...e,...t}},a=s("backend"),r=new Set,h=new Set,d=new Set,l=new Map,m=n((t,e)=>({scope:e,payload:t,signal:(new AbortController).signal,get state(){return o()},setState(){throw Error("[BackendRuntime] setState not allowed")},emit:y})),p=[];async function y(t,e){r.forEach(s=>s(t,e));const s=new AbortController;try{await m.emit(t,e,a);const n=l.get(t);if(n)for(const t of n)await t({state:o,set:i,emit:y,signal:s.signal},e)}catch(e){throw d.forEach(s=>s(e,t)),e}finally{h.forEach(s=>s(t,e))}}const g={state:o,reset:()=>{e=c(t)},emit:y,registerIntents:function(t){for(const e in t){const s=t[e],n=m.on(e,async t=>{const e={state:o,set:i,emit:y,signal:t.signal};await s(e,t.payload)},a);"function"==typeof n&&p.push(n)}},effect:function(t,e){return l.has(t)||l.set(t,new Set),l.get(t).add(e),()=>{l.get(t).delete(e)}},onError:t=>(d.add(t),()=>d.delete(t)),onBefore:t=>(r.add(t),()=>r.delete(t)),onAfter:t=>(h.add(t),()=>h.delete(t)),destroy(){r.clear(),h.clear(),d.clear(),l.clear();for(const t of p)t();p.length=0}};if(u){const t=f(g);t.wrap(),g.devtools=t}return g}export{a as LogicRuntime,f as attachDevtools,l as createApp,m as createBackendRuntime,d as createIntentBus,h as createLogic,r as effect,c as safeClone};
