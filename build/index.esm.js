import{signal as t,createScope as e,effect as s,createIntentBus as n}from"intentx-core-z";const o=function(t){const e=function(t){return function(e,s){const n=t(e),o=n.set;return n.set=(t,e="normal")=>{const i=n(),a=s?s(t,i):t;o(a,e)},n.update=(t,e="normal")=>{n.set(t(n()),e)},n}}(t);return function(t,s){var n;const o=null!==(n=null==s?void 0:s.equals)&&void 0!==n?n:Object.is;return e(t,(t,e)=>o(t,e)?e:t)}}(t);class i{constructor(){this.handlers={},this.effects={},this.middlewares=[]}use(t){this.middlewares.push(t)}effect(t,e){var s,n;(null!==(s=(n=this.effects)[t])&&void 0!==s?s:n[t]=[]).push(e)}on(t,e){var s,n;const o=null!==(s=(n=this.handlers)[t])&&void 0!==s?s:n[t]=[];return o.length>0?(console.warn(`[IntentBus] Duplicate intent handler "${t}" detected. Only the first handler will be used.`),()=>{}):(o.push(e),()=>{const s=this.handlers[t];if(!s)return;const n=s.indexOf(e);n>=0&&s.splice(n,1),0===s.length&&delete this.handlers[t]})}async emit(t,e){var s,n;const o=null!==(s=this.handlers[t])&&void 0!==s?s:[],i=null!==(n=this.effects[t])&&void 0!==n?n:[],a=(r=this.middlewares,c=async t=>{t.effects=i;for(const e of o)await e(t)},r.reduceRight((t,e)=>e(t),c));var r,c;await a(e)}}class a{constructor(t,s=e("logic"),n){this.computedAtoms={},this.subs=new Set,this.dirty=!0,this.isComputing=!1,this.isBatching=!1,this.computedKeys=new Set,this.errorHandlers=new Set,this.leadingLocks=new Set,this.throttleMap=new Map,this.markDirty=()=>{this.isBatching||(this.dirty=!0,this.subs.forEach(t=>t()))},this.getSnapshot=()=>(this.dirty&&(this.snapshotCache=this.buildSnapshot(),this.dirty=!1),this.snapshotCache),this.subscribe=t=>(this.subs.add(t),()=>this.subs.delete(t)),this.onIntent=(t,e)=>this.bus.on(t,e),this.emit=async(t,e)=>{const s=new AbortController;try{await this.bus.emit(t,{payload:e,scope:this.scope,signal:s.signal,state:this.getSnapshot,setState:t=>this.setStateInternal(t),emit:this.emit})}catch(s){this.errorHandlers.forEach(n=>n(s,{type:t,payload:e}))}},this.scope=s,this.stateAtoms=this.createStateAtoms(t);for(const t in this.stateAtoms)this.stateAtoms[t].subscribe(this.markDirty);this.bus=null!=n?n:new i,this.bus.use(function(){const t=new Map,e=new Map;return s=>async n=>{var o;await s(n);const i=n.effects;if(null==i?void 0:i.length)for(const s of i){const i=s.id;if("takeLatest"===s.strategy){null===(o=t.get(i))||void 0===o||o.abort();const e=new AbortController;t.set(i,e),await s.handler({...n,signal:e.signal})}else"debounce"===s.strategy?(clearTimeout(e.get(i)),await new Promise(t=>{e.set(i,setTimeout(async()=>{await s.handler(n),t()},s.wait))})):await s.handler(n)}}}())}createStateAtoms(t){const e={};for(const s in t)e[s]=o(t[s]);return e}buildSnapshot(){const t={};for(const e in this.stateAtoms)t[e]=this.stateAtoms[e]();for(const e in this.computedAtoms)t[e]=this.computedAtoms[e]();return t}createReactiveState(){return new Proxy({},{get:(t,e)=>{const s=this.stateAtoms[e];return s?s():void 0}})}get state(){return this.getSnapshot()}get computed(){const t={};return this.computedKeys.forEach(e=>{t[e]=this.computedAtoms[e]()}),t}batch(t){this.isBatching=!0;try{t()}finally{this.isBatching=!1,this.markDirty()}}onError(t){return this.errorHandlers.add(t),()=>this.errorHandlers.delete(t)}getComputedKey(t){return this.computedAtoms[t]()}getComputed(t){const e={};return this.computedKeys.forEach(s=>{e[s]=t[s]}),e}setStateInternal(t){this.isComputing&&console.warn("[intentx-runtime] setState() inside computed()");const e={};for(const t in this.stateAtoms)e[t]=this.stateAtoms[t]();t(e);for(const t in this.stateAtoms)e[t]!==this.stateAtoms[t]()&&this.stateAtoms[t].set(e[t])}once(t,e){const s=this.onIntent(t,async t=>{s(),await e(t)})}takeLeading(t,e){this.onIntent(t,async s=>{if(!this.leadingLocks.has(t)){this.leadingLocks.add(t);try{await e(s)}finally{this.leadingLocks.delete(t)}}})}throttle(t,e,s){this.onIntent(t,async n=>{var o;const i=Date.now();i-(null!==(o=this.throttleMap.get(t))&&void 0!==o?o:0)<e||(this.throttleMap.set(t,i),await s(n))})}useEffect(t,e){this.bus.effect(t,e)}attachComputed(t,e){const n=o(void 0),i=this.createReactiveState();this.computedAtoms[t]=n,this.computedKeys.add(t);const a=()=>{this.isComputing=!0,n.set(e({state:i})),this.isComputing=!1};s(a),a(),n.subscribe(this.markDirty)}}function r(t){const e={_kind:"effect",id:Symbol("effect"),handler:t,strategy:"default",wait:0};return Object.assign(e,{takeLatest:()=>(e.strategy="takeLatest",e),debounce:t=>(e.strategy="debounce",e.wait=t,e)})}function c(t){return{name:t.name,createShareBus(t,e){return this.create(t,e)},createIsolated(t){return this.create(t,void 0)},create(e,s){var n;const o=new a(structuredClone(t.state),e,s);if(t.computed)for(const e in t.computed)o.attachComputed(e,t.computed[e]);null===(n=t.intents)||void 0===n||n.call(t,{on:o.onIntent,effect:o.useEffect.bind(o)});const i={};if(t.actions){const e=Object.keys(t.actions);for(const s of e){const e=t.actions[s];i[s]=e({emit:o.emit,getState:o.getSnapshot})}}return o.actions=i,o}}}function h(t){var s;const n=e(null!==(s=t.name)&&void 0!==s?s:"app"),o=new i,a={};for(const e of Object.keys(t.logics)){const s=t.logics[e];a[e]=s.createShareBus(n,o)}return{scope:n,bus:o,logics:a}}function l(t){const e=function(){let t=0,e=[];return{get records(){return e.slice()},record:function(s){e.push({...s,id:++t,state:structuredClone(s.state)})},replay:async function(t,s){const{from:n=0,to:o=1/0,scope:i}=null!=s?s:{},a=e.filter(t=>"emit"===t.type&&t.id>=n&&t.id<=o&&(!i||t.scope===i));for(const e of a){const s=t(e.intent,e.payload);s instanceof Promise&&await s}},clear:function(){e=[],t=0}}}(),s=Symbol("devtools_wrapped");function n(){return"string"==typeof t.scope?t.scope:t.scope.name}function o(){return"function"==typeof t.getSnapshot?t.getSnapshot():"function"==typeof t.state?t.state():void 0}return{timeline:e,wrap:function(){if(t[s])return;t[s]=!0;const i=t.emit.bind(t);t.emit=async(t,s)=>{e.record({type:"emit:start",intent:t,payload:s,scope:n(),state:o(),timestamp:Date.now()});try{await Promise.resolve(i(t,s))}catch(i){throw e.record({type:"emit:error",intent:t,payload:s,scope:n(),state:o(),timestamp:Date.now()}),i}e.record({type:"emit:end",intent:t,payload:s,scope:n(),state:o(),timestamp:Date.now()})}}}}function u(t){var s,o;let i=structuredClone(t);const a=()=>i,r=t=>{i={...i,...t}},c=e("backend"),h=new Set,u=new Set,d=new Set,f=n((t,e)=>({scope:e,payload:t,signal:(new AbortController).signal,get state(){return a()},setState(){throw new Error("[BackendRuntime] setState not allowed")},emit:m}));async function m(t,e){h.forEach(s=>s(t,e));try{await f.emit(t,e,c)}catch(e){throw d.forEach(s=>s(e,t)),e}finally{u.forEach(s=>s(t,e))}}const p={state:a,reset:()=>{i=structuredClone(t)},emit:m,registerIntents:function(t){for(const e in t){const s=t[e];f.on(e,async(t,e)=>{const n={get state(){return a()},signal:t.signal,set:r,emit:m};await s(n,e)},c)}},onIntent:f.on,effect:f.effect,onError:t=>(d.add(t),()=>d.delete(t)),onBefore:t=>(h.add(t),()=>h.delete(t)),onAfter:t=>(u.add(t),()=>u.delete(t)),destroy(){h.clear(),u.clear(),d.clear()}};if("production"!==(null===(o=null===(s=null===globalThis||void 0===globalThis?void 0:globalThis.process)||void 0===s?void 0:s.env)||void 0===o?void 0:o.NODE_ENV)){const t=l(p);t.wrap(),p.devtools=t}return p}export{a as LogicRuntime,l as attachDevtools,h as createApp,u as createBackendRuntime,c as createLogic,r as effect};
