import{atom as t,effect as e}from"intentx-state-z";export{createScope}from"intentx-state-z";import{createScope as s,createIntentBus as o}from"intentx-core-z";class i{constructor(){this.handlers={},this.effects={},this.middlewares=[],this.effectModes={},this.use=t=>{this.middlewares.push(t)},this.setEffectMode=(t,e)=>{this.effectModes[t]=e},this.effect=(t,e)=>{var s;((s=this.effects)[t]??(s[t]=[])).push(e)},this.on=(t,e)=>{var s;const o=(s=this.handlers)[t]??(s[t]=[]);return o.length>0?()=>{}:(o.push(e),()=>{const s=this.handlers[t];if(!s)return;const o=s.indexOf(e);0>o||s.splice(o,1),0===s.length&&delete this.handlers[t]})},this.emit=async(t,e)=>{const s=this.handlers[t]??[],o={context:e,effects:this.effects[t]??[],effectMode:this.effectModes[t]??"sequential"},i=this.middlewares.reduceRight((t,e)=>e(t),async t=>{for(const e of s)await e(t.context)});await i(o)},this.clear=()=>{this.handlers={},this.effects={},this.middlewares=[],this.effectModes={}}}}function n(){const t=new Map,e=new Map;return s=>async o=>{await s(o);const{effects:i,effectMode:n,context:a}=o;if(!i.length)return;const r=i.map(s=>()=>(async s=>{const o=s.id;if("takeLatest"===s.strategy){t.get(o)?.abort();const e=new AbortController;return t.set(o,e),s.handler({...a,signal:e.signal})}return"debounce"===s.strategy?(clearTimeout(e.get(o)),new Promise(t=>{e.set(o,setTimeout(async()=>{await s.handler(a),t()},s.wait))})):s.handler(a)})(s));switch(n){case"parallel":await Promise.all(r.map(t=>t()));break;case"race":await Promise.race(r.map(t=>t()));break;case"allSettled":await Promise.allSettled(r.map(t=>t()));break;default:for(const t of r){const e=t();await e}}}}function a(t){return"function"==typeof structuredClone?structuredClone(t):JSON.parse(JSON.stringify(t))}function r(t){if(null===t||"object"!=typeof t)return t;Object.freeze(t);for(const e of Object.keys(t)){const s=t[e];s&&"object"==typeof s&&!Object.isFrozen(s)&&r(s)}return t}const c=void 0!==import.meta?import.meta.env:void 0,h="undefined"!=typeof globalThis&&void 0!==globalThis.process?globalThis.process?.env?.NODE_ENV:void 0,d=c?.DEV??(!!h&&"production"!==h);class l{constructor(o,a=s("logic"),c){this.computedAtoms={},this.subs=new Set,this.dirty=!0,this.isComputing=!1,this.isBatching=!1,this.destroyed=!1,this.computedKeys=new Set,this.computedDisposers=new Set,this.intentDisposers=new Set,this.errorHandlers=new Set,this.leadingLocks=new Set,this.throttleMap=new Map,this.destroy=()=>{this.destroyed||(this.destroyed=!0,this.subs.clear(),this.computedDisposers.forEach(t=>t()),this.computedDisposers.clear(),this.intentDisposers.forEach(t=>t()),this.intentDisposers.clear(),this.leadingLocks.clear(),this.throttleMap.clear(),this.errorHandlers.clear(),this.computedKeys.clear(),this.dirty=!0)},this.createStateAtoms=e=>{const s={};for(const o in e)s[o]=t(e[o]);return s},this.buildSnapshot=()=>{const t={};for(const e in this.stateAtoms)t[e]=this.stateAtoms[e]();for(const e in this.computedAtoms)t[e]=this.computedAtoms[e]();return d?r(t):t},this.markDirty=()=>{this.destroyed||this.isBatching||(this.dirty=!0,this.subs.forEach(t=>t()))},this.createReactiveState=()=>new Proxy({},{get:(t,e)=>{const s=this.stateAtoms[e];return s?s():void 0}}),this.getSnapshot=()=>this.destroyed?this.snapshotCache??this.buildSnapshot():(this.dirty&&(this.snapshotCache=this.buildSnapshot(),this.dirty=!1),this.snapshotCache),this.subscribe=t=>this.destroyed?()=>{}:(this.subs.add(t),()=>this.subs.delete(t)),this.batch=t=>{if(!this.destroyed){this.isBatching=!0;try{t()}finally{this.isBatching=!1,this.markDirty()}}},this.onError=t=>(this.errorHandlers.add(t),()=>this.errorHandlers.delete(t)),this.getComputedKey=t=>this.computedAtoms[t](),this.getComputed=t=>{const e={};return this.computedKeys.forEach(s=>{e[s]=t[s]}),e},this.setStateInternal=t=>{const e={};for(const t in this.stateAtoms)e[t]=this.stateAtoms[t]();t(e);for(const t in this.stateAtoms)e[t]!==this.stateAtoms[t]()&&this.stateAtoms[t].set(e[t])},this.onIntent=(t,e)=>{const s=this.bus.on(t,e);return this.intentDisposers.add(s),()=>{s(),this.intentDisposers.delete(s)}},this.once=(t,e)=>{const s=this.onIntent(t,async t=>{s(),await e(t)})},this.takeLeading=(t,e)=>{this.onIntent(t,async s=>{if(!this.leadingLocks.has(t)){this.leadingLocks.add(t);try{await e(s)}finally{this.leadingLocks.delete(t)}}})},this.throttle=(t,e,s)=>{this.onIntent(t,async o=>{const i=Date.now();i-(this.throttleMap.get(t)??0)<e||(this.throttleMap.set(t,i),await s(o))})},this.useEffect=(t,e)=>{this.bus.effect(t,e)},this.emit=async(t,e)=>{if(this.destroyed)return;const s=new AbortController;try{await this.bus.emit(t,{payload:e,scope:this.scope,signal:s.signal,state:this.getSnapshot,setState:this.setStateInternal,emit:this.emit})}catch(s){this.errorHandlers.forEach(o=>o(s,{type:t,payload:e}))}},this.attachComputed=(s,o)=>{const i=t(void 0),n=this.createReactiveState();this.computedAtoms[s]=i,this.computedKeys.add(s);const a=()=>{this.destroyed||(this.isComputing=!0,i.set(o({state:n})),this.isComputing=!1)},r=e(a);this.computedDisposers.add(r),a();const c=i.subscribe(this.markDirty);this.computedDisposers.add(c)},this.scope=a,this.stateAtoms=this.createStateAtoms(o);for(const t in this.stateAtoms){const e=this.stateAtoms[t].subscribe(this.markDirty);this.computedDisposers.add(e)}c?this.bus=c:(this.bus=new i,this.bus.use(n())),d&&(this.__debugId="runtime-"+Math.random().toString(36).slice(2))}get state(){return this.getSnapshot()}get computed(){const t={};return this.computedKeys.forEach(e=>{t[e]=this.computedAtoms[e]()}),t}}function f(t){const e={_kind:"effect",id:Symbol("effect"),handler:t,strategy:"default"},s=(t={})=>{const o={...e,...t};return Object.assign(o,{takeLatest:()=>s({strategy:"takeLatest"}),debounce:t=>s({strategy:"debounce",wait:t}),blocking:()=>s({blocking:!0})})};return s()}function u(t,e){const s=function(){let t=0,e=[];return{get records(){return e.slice()},record:function(s){e.push({...s,id:++t,state:a(s.state)})},replay:async function(t,s){const{from:o=0,to:i=1/0,scope:n}=s??{},a=e.filter(t=>!("emit"!==t.type||o>t.id||t.id>i||n&&t.scope!==n));for(const e of a){const s=t(e.intent,e.payload);s instanceof Promise&&await s}},clear:function(){e=[],t=0}}}(),o=Symbol("devtools_wrapped");function i(){const s=e||t.scope;return s?"string"==typeof s?s:s.name??"anonymous":"global"}function n(){return"function"==typeof t.getSnapshot?t.getSnapshot():"function"==typeof t.state?t.state():void 0}return{timeline:s,wrap:function(){if(t[o])return;t[o]=!0;const e=t.emit.bind(t);t.emit=async(t,o)=>{s.record({type:"emit:start",intent:t,payload:o,scope:i(),state:n(),timestamp:Date.now()});try{await Promise.resolve(e(t,o))}catch(e){throw s.record({type:"emit:error",intent:t,payload:o,scope:i(),state:n(),timestamp:Date.now()}),e}s.record({type:"emit:end",intent:t,payload:o,scope:i(),state:n(),timestamp:Date.now()})}}}}function p(t){return{name:t.name,createShareBus(t,e){return this.create(t,e)},createIsolated(t){return this.create(t,void 0)},create(e,s){const o=new l(a(t.state),e,s);if(d&&!o.devtools){const e=u(o,t.name??"logic");e.wrap(),o.devtools=e}if(t.computed)for(const e in t.computed)o.attachComputed(e,t.computed[e]);t.intents?.({on:o.onIntent,effect:(t,e)=>o.useEffect(t,e)});const i={};if(t.actions){const e=Object.keys(t.actions);for(const s of e){i[s]=(0,t.actions[s])({emit:o.emit,getState:o.getSnapshot})}}return o.actions=i,o}}}const m=()=>new i;function y(t){const e=s(t.name??"app"),o=m(),i={};for(const s of Object.keys(t.logics)){i[s]=t.logics[s].createShareBus(e,o)}return{scope:e,bus:o,logics:i}}function g(t){let e=a(t);const i=()=>e,n=t=>{e={...e,...t}},r=s("backend"),c=new Set,h=new Set,l=new Set,f=new Map,p=o((t,e)=>({scope:e,payload:t,signal:(new AbortController).signal,get state(){return i()},setState(){throw Error("[BackendRuntime] setState not allowed")},emit:y})),m=[];async function y(t,e){c.forEach(s=>s(t,e));const s=new AbortController;try{await p.emit(t,e,r);const o=f.get(t);if(o)for(const t of o)await t({state:i,set:n,emit:y,signal:s.signal},e)}catch(e){throw l.forEach(s=>s(e,t)),e}finally{h.forEach(s=>s(t,e))}}const g={state:i,reset:()=>{e=a(t)},emit:y,registerIntents:function(t){for(const e in t){const s=t[e],o=p.on(e,async t=>{const e={state:i,set:n,emit:y,signal:t.signal};await s(e,t.payload)},r);"function"==typeof o&&m.push(o)}},effect:function(t,e){return f.has(t)||f.set(t,new Set),f.get(t).add(e),()=>{f.get(t).delete(e)}},onError:t=>(l.add(t),()=>l.delete(t)),onBefore:t=>(c.add(t),()=>c.delete(t)),onAfter:t=>(h.add(t),()=>h.delete(t)),destroy(){c.clear(),h.clear(),l.clear(),f.clear();for(const t of m)t();m.length=0}};if(d&&!g.devtools){const t=u(g,"logic");t.wrap(),g.devtools=t}return g}export{l as LogicRuntime,u as attachDevtools,y as createApp,g as createBackendRuntime,m as createIntentBus,p as createLogic,r as deepFreeze,f as effect,a as safeClone};
